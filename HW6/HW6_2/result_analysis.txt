[How do their performance compare?]
    See result_time.png for details about how long each counter takes.
    DistributedCounter1 takes almost 3 times more time than DistributedCounter2 and DistributedCounter3 to finish counting 1000000000.
    DistributedCounter2 and DistributedCounter3 took almost the same time to run.

[What do you conclude?]
    DistributedCounter2 and DistributedCounter3 take less time to run because they implemented multiple "sub-counters" so different threads are less likely to use the same sub counter. In DistributedCounter1 it is very likely that different threads are modifying the same sub counter and lock each other out before they could count and thus slower. Creating multiple sub-counters reduces contention.

[Do you think your results would be the same on other computers? Why or why not?]
    Results will be different on other computers.
    As we discussed in class, DistributedCounter2 actually has this "false-sharing" problem because all sub-counters are stored in an array so many of them end up on the same cache line, and so all threads need to reload the counters. In a machine that has different cache lines, this is very slow and could be solved by adding a padding line (as in DistributedCounter3). 
